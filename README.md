| Problem                                                                                                             | Difficulty | Related Topics                     | Solution                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------- | ---------- | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Contains Duplicate](https://github.com/rad16x/grinding-leetcode/blob/main/containsDuplicate.go)                    | Easy       | Array, Hash Table                  | Used a hash table to check for duplicate values in the 'nums' array. Created a map, checkDup , to keep track of unique elements. Iterated through the array, and for each element, checked if it already exists in the checkDup map. If it did, returned true to indicate the presence of a duplicate; otherwise, marked the element as seen in the map. If no duplicates were found, returned false.                                                                                                                                                  |
| [Valid Anagram](https://github.com/rad16x/grinding-leetcode/blob/main/validAnagram.go)                              | Easy       | String                             | Checked if the lengths of strings s and t are different; if so, returned false. Created character count arrays for both strings, where each index represents a letter's count. Compared the character count arrays and returned false if they didn't match, indicating that t is not an anagram of s. Returned true if the arrays matched.                                                                                                                                                                                                             |
| [Two Sum](https://github.com/rad16x/grinding-leetcode/blob/main/twoSum.go)                                          | Easy       | Array, Hash Table                  | Created a map, indexMap, to store the indices of elements as they are iterated through the nums array. For each element, checked if the complement (i.e., target - num) exists in the map. If it did, returned the indices of the two numbers whose sum equals the target. Otherwise, stored the current element's index in the map. If no valid pair was found, returned an empty array.                                                                                                                                                              |
| [Group Anagrams](https://github.com/rad16x/grinding-leetcode/blob/main/twoSum.go)                                   | Medium     | String, Hash Table                 | Grouped anagrams from the strs array using a hash map. For each string, created a key represented as a [26]byte array, where each element counts the occurrence of a letter in the string. Added the string to the corresponding key in the map. Finally, collected the grouped anagrams from the map into a result array and returned it.                                                                                                                                                                                                             |
| [Top K Frequent Elements](https://github.com/rad16x/grinding-leetcode/blob/main/topKFrequentElements.go)            | Medium     | Array, Hash Table, Sorting         | Identified the frequency of each element in the nums array using a hash map countMap. Created a structure Pair, to hold the value and frequency of each element. Constructed a slice pairs, to store the pairs of values and frequencies from the map. Sorted the pairs in descending order of frequency. Extracted the top K frequent elements from the sorted pairs and returned them.                                                                                                                                                               |
| [Product of Array Except Self](https://github.com/rad16x/grinding-leetcode/blob/main/productOfArrayExceptSelf.go)   | Medium     | Array                              | This solution efficiently calculates the product using two passes. In the first pass, it computes the product of all elements to the left of each element and stores it in the res array. In the second pass, it calculates the product of all elements to the right of each element and multiplies it with the corresponding value in the res array. The result is an array where each element represents the product of all elements in nums except the element itself.                                                                              |
| [Longest Consecutive Sequence](https://github.com/rad16x/grinding-leetcode/blob/main/longestConsecutiveSequence.go) | Medium     | Array, Hash Table                  | The algorithm uses a hash set numSet to identify consecutive sequences within the unsorted array nums. It iterates through the array, extending sequences left and right while keeping track of the longest streak found. This streak length is returned as the result.                                                                                                                                                                                                                                                                                |
| [Valid Palindrome](https://github.com/rad16x/grinding-leetcode/blob/main/validPalindrome.go)                        | Easy       | String, Two Pointers               | Utilizes two pointers, left and right to traverse the string and compare characters. The algorithm skips non-alphanumeric characters and performs a case-insensitive comparison of alphanumeric characters. If any pair of characters does not match, it returns false. If the traversal is completed without encountering any mismatches, the string is deemed a valid palindrome, and the function returns true.                                                                                                                                     |
| [Two Sum II](https://github.com/rad16x/grinding-leetcode/blob/main/twoSumII.go)                                     | Medium     | Array, Two Pointers, Binary Search | Utilizes a two-pointer approach and binary search to efficiently find a pair of numbers in the sorted array that add up to the target. The algorithm iterates through the array, incrementally adjusting the pointers based on the calculated sum of elements. If the sum matches the target, it returns the indices of the two numbers. If the sum is less than the target, it advances the left pointer, and if the sum is greater, it shifts the right pointer. This process continues until a solution is found or all possibilities are explored. |
